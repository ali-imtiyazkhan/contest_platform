generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  User
  Admin
}

enum Type {
  Easy
  Medium
  Hard
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String?
  role     Role    @default(User)
  rating   Int     @default(1200)

  contestSubmissions  ContestSubmission[]
  leaderboard         Leaderboard[]
  ratingHistories     RatingHistory[]
  contestParticipants ContestParticipant[]
}

model OtpVerification {
  id        String   @id @default(uuid())
  email     String   @unique
  otp       String
  attempts  Int      @default(0)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Contest {
  id          String   @id @default(uuid())
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime
  createdAt   DateTime @default(now())

  contestToChallengeMapping ContestToChallengeMapping[]
  leaderboard               Leaderboard[]
  ratingHistories           RatingHistory[]
  contestParticipants       ContestParticipant[]
}

model Challenge {
  id            String        @id @default(uuid())
  title         String
  notionDocId   String
  maxPoints     Int
  description   String?
  createdAt     DateTime      @default(now())
  contextStatus ContextStatus @default(Pending)

  aiContext String?
  type      Type?

  contestToChallengeMapping ContestToChallengeMapping[]
}

model ContestToChallengeMapping {
  id          String @id @default(uuid())
  contestId   String
  challengeId String
  index       Int

  contest   Contest   @relation(fields: [contestId], references: [id], onDelete: Cascade)
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  submissions ContestSubmission[]

  @@unique([contestId, challengeId])
}

enum ContextStatus {
  Pending
  Generating
  Completed
  Failed
}

model ContestSubmission {
  id                          String @id @default(uuid())
  submission                  String
  contestToChallengeMappingId String
  userId                      String

  points    Int              @default(0)
  aiVerdict String?
  aiReason  String?
  createdAt DateTime         @default(now())
  status    SubmissionStatus @default(Pending)

  user                      User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  contestToChallengeMapping ContestToChallengeMapping @relation(fields: [contestToChallengeMappingId], references: [id], onDelete: Cascade)

  @@unique([contestToChallengeMappingId, userId])
}

model Leaderboard {
  id        String @id @default(uuid())
  contestId String
  userId    String
  score     Int    @default(0)

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contestId, userId])
  @@index([contestId, score])
}

enum SubmissionStatus {
  Pending
  Judging
  Accepted
  Rejected
}

model RatingHistory {
  id        String   @id @default(uuid())
  userId    String
  contestId String
  before    Int
  after     Int
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model ContestParticipant {
  id           String   @id @default(uuid())
  contestId    String
  userId       String
  registeredAt DateTime @default(now())

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contestId, userId])
  @@index([contestId])
}
